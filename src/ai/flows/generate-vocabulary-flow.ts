
'use server';
/**
 * @fileOverview Generates a list of vocabulary words for a given language and mode.
 *
 * - generateVocabulary - A function that handles vocabulary generation.
 * - GenerateVocabularyInput - The input type for the generateVocabulary function.
 * - GenerateVocabularyOutput - The return type for the generateVocabulary function.
 */

import { ai } from '@/ai/genkit';
import { z } from 'genkit'; // genkit re-exports z from zod

// Schema for a single vocabulary word (matches DailyWordItem structure elements)
const VocabularyWordSchema = z.object({
  wordBankId: z.string().describe('A unique identifier for the word (will be generated by the flow).'),
  word: z.string().describe('The vocabulary word in the target language.'),
  translation: z.string().describe('The translation of the word into the specified native language.'),
  exampleSentence: z.string().describe('An example sentence using the word in the target language.'),
  wordType: z.enum(['noun', 'verb', 'adjective', 'phrase', 'other']).describe('The grammatical type of the word.'),
  dataAiHint: z.string().describe('A short hint (1-2 words) for generating an image related to the word/example. Do not include the word itself in the hint.'),
});

// Input schema for the flow
export const GenerateVocabularyInputSchema = z.object({
  languageName: z.string().describe("The name of the target language (e.g., 'Spanish', 'French')."),
  languageCode: z.string().describe("The code of the target language (e.g., 'es', 'fr')."),
  modeName: z.string().describe("The name of the learning mode (e.g., 'Travel', 'Conversational')."),
  nativeLanguageName: z.string().describe("The user's native language (e.g., 'English'). The translation should be to this language."),
  count: z.number().int().positive().min(5).max(15).default(7).describe("The number of vocabulary words to generate."),
});
export type GenerateVocabularyInput = z.infer<typeof GenerateVocabularyInputSchema>;

// Output schema for the flow, containing an array of the vocabulary words
const GenerateVocabularyOutputSchema = z.object({
  vocabulary: z.array(
    // The output from the LLM won't have wordBankId, so we make it optional here for the raw output
    VocabularyWordSchema.omit({ wordBankId: true }) 
  ).describe('A list of generated vocabulary words, excluding wordBankId which is added by the flow.'),
});
export type GenerateVocabularyOutput = z.infer<typeof GenerateVocabularyOutputSchema>;

// Final output type for the exported wrapper function, which includes wordBankId
export type GenerateVocabularyResult = {
  vocabulary: z.infer<typeof VocabularyWordSchema>[];
};


// Exported wrapper function for client/server component consumption
export async function generateVocabulary(input: GenerateVocabularyInput): Promise<GenerateVocabularyResult> {
  return _generateVocabularyFlow(input);
}

const vocabularyPrompt = ai.definePrompt({
  name: 'generateVocabularyPrompt',
  input: { schema: GenerateVocabularyInputSchema },
  output: { schema: GenerateVocabularyOutputSchema }, // LLM output schema doesn't include wordBankId
  prompt: `You are an expert linguist creating vocabulary lists for a language learning app.
Generate a diverse list of exactly {{{count}}} vocabulary words for learning {{{languageName}}}, tailored for a "{{{modeName}}}" learning mode.
The user's native language is {{{nativeLanguageName}}}. All translations MUST be into {{{nativeLanguageName}}}.

For each word, provide the following fields:
- word: The word in {{{languageName}}}.
- translation: The accurate translation of the word into {{{nativeLanguageName}}}.
- exampleSentence: A simple, illustrative sentence using the word in {{{languageName}}}. The sentence should be natural and easy for a learner to understand.
- wordType: The grammatical type of the word (must be one of: noun, verb, adjective, phrase, other).
- dataAiHint: A concise hint (1-2 words, e.g., "fruit basket", "fast car") for generating a relevant image. Do not include the word itself in the hint.

Ensure the words are common, practical, and useful for a beginner to intermediate learner in the specified {{{languageName}}} and {{{modeName}}}.
The list should not contain duplicate words.

Return ONLY the JSON object matching the output schema. Do not include any introductory text, explanations, or markdown formatting like \`\`\`json.
The root of the JSON object must be a "vocabulary" array.
Example of a single item in the "vocabulary" array (excluding wordBankId):
{
  "word": "ejemplo",
  "translation": "example (to specified native language)",
  "exampleSentence": "Este es un buen ejemplo.",
  "wordType": "noun",
  "dataAiHint": "instruction illustration"
}
`,
});

const _generateVocabularyFlow = ai.defineFlow(
  {
    name: 'generateVocabularyFlowInternal', // Renamed internal flow
    inputSchema: GenerateVocabularyInputSchema,
    outputSchema: VocabularyWordSchema.array(), // The flow will ultimately return the full schema array
  },
  async (input): Promise<z.infer<typeof VocabularyWordSchema>[]> => { // Return type is array of full VocabularyWordSchema
    const { output } = await vocabularyPrompt(input);

    if (!output || !output.vocabulary) {
      console.error('Vocabulary generation prompt failed or returned empty/invalid data from LLM.');
      // Consider throwing an error or returning a predefined empty/error structure
      // For now, returning an empty array to allow fallback on the client.
      return [];
    }

    // Add unique wordBankId to each item
    const vocabularyWithIds = output.vocabulary.map((item, index) => ({
      ...item,
      wordBankId: `${input.languageCode}_${input.modeName.replace(/\s+/g, '-').toLowerCase()}_${Date.now()}_${index}`,
    }));

    return vocabularyWithIds; // This matches the flow's outputSchema now
  }
);
