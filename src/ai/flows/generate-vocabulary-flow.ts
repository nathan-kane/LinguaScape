
'use server';
/**
 * @fileOverview Generates a list of vocabulary words in a target language for a given mode,
 * with example sentences in the target language. Native translation is fetched on-demand by the client.
 *
 * - generateVocabulary - A function that handles vocabulary generation.
 * - GenerateVocabularyInput - The input type for the generateVocabulary function.
 * - GenerateVocabularyResult - The return type for the generateVocabulary function.
 */

import { ai } from '@/ai/genkit';
import { z } from 'genkit'; // genkit re-exports z from zod

// Schema for a single vocabulary word (as returned by this flow)
const VocabularyWordSchema = z.object({
  wordBankId: z.string().describe('A unique identifier for the word (will be generated by the flow).'),
  wordInTargetLanguage: z.string().describe('The vocabulary word in the target language.'),
  exampleSentenceInTargetLanguage: z.string().describe('An example sentence using the word, in the target language.'),
  wordType: z.enum(['noun', 'verb', 'adjective', 'phrase', 'other']).describe('The grammatical type of the word.'),
  dataAiHint: z.string().describe('A short hint (1-2 words) for generating an image related to the word/example. Do not include the word itself in the hint.'),
});

// Input schema for the flow
const GenerateVocabularyInputSchema = z.object({
  languageName: z.string().describe("The name of the target language for word and sentence generation (e.g., 'Spanish', 'French')."),
  languageCode: z.string().describe("The code of the target language (e.g., 'es', 'fr'). Used for wordBankId generation."),
  modeName: z.string().describe("The name of the learning mode (e.g., 'Travel', 'Conversational')."),
  nativeLanguageName: z.string().describe("The user's native language (e.g., 'English'). This is NOT used for translation by this flow, but passed for context if needed by LLM for word selection relevance."),
  count: z.number().int().positive().min(5).max(15).default(7).describe("The number of vocabulary words to generate."),
});
export type GenerateVocabularyInput = z.infer<typeof GenerateVocabularyInputSchema>;

// Output schema from the LLM (before we add wordBankId)
const GenerateVocabularyLLMOutputSchema = z.object({
  vocabulary: z.array(
    VocabularyWordSchema.omit({ wordBankId: true }) 
  ).describe('A list of generated vocabulary words in the target language, excluding wordBankId which is added by the flow.'),
});
export type GenerateVocabularyLLMOutput = z.infer<typeof GenerateVocabularyLLMOutputSchema>;


// Final output type for the exported wrapper function
export type GenerateVocabularyResult = {
  vocabulary: z.infer<typeof VocabularyWordSchema>[];
};


// Exported wrapper function
export async function generateVocabulary(input: GenerateVocabularyInput): Promise<GenerateVocabularyResult> {
  const flowResult = await _generateVocabularyFlow(input);
  return { vocabulary: flowResult };
}

const vocabularyPrompt = ai.definePrompt({
  name: 'generateTargetLanguageVocabularyPrompt',
  input: { schema: GenerateVocabularyInputSchema },
  output: { schema: GenerateVocabularyLLMOutputSchema },
  prompt: `You are an expert linguist creating vocabulary lists for a language learning app.
Generate a diverse list of exactly {{{count}}} vocabulary words for learning {{{languageName}}}, tailored for a "{{{modeName}}}" learning mode.
The user's native language is {{{nativeLanguageName}}}, which might give context to the types of words a beginner in {{{languageName}}} might need.

For each word, provide the following fields ALL in the TARGET language ({{{languageName}}}):
- wordInTargetLanguage: The word in {{{languageName}}}.
- exampleSentenceInTargetLanguage: A simple, illustrative sentence using the word, also in {{{languageName}}}. The sentence should be natural and easy for a learner to understand.
- wordType: The grammatical type of the word (must be one of: noun, verb, adjective, phrase, other).
- dataAiHint: A concise hint (1-2 words, e.g., "fruit basket", "fast car") for generating a relevant image. This hint should be in English or very simple universal terms, and not include the word itself.

Ensure the words are common, practical, and useful for a beginner to intermediate learner in the specified {{{languageName}}} and {{{modeName}}}.
The list should not contain duplicate words.

Return ONLY the JSON object matching the output schema. Do not include any introductory text, explanations, or markdown formatting like \`\`\`json.
The root of the JSON object must be a "vocabulary" array.
Example of a single item (imagine {{{languageName}}} is Spanish):
{
  "wordInTargetLanguage": "manzana",
  "exampleSentenceInTargetLanguage": "La manzana es roja y deliciosa.",
  "wordType": "noun",
  "dataAiHint": "apple fruit"
}
`,
});

const _generateVocabularyFlow = ai.defineFlow(
  {
    name: 'generateTargetLanguageVocabularyFlowInternal',
    inputSchema: GenerateVocabularyInputSchema,
    outputSchema: VocabularyWordSchema.array(), // Flow returns array of full VocabularyWordSchema
  },
  async (input): Promise<z.infer<typeof VocabularyWordSchema>[]> => {
    const { output } = await vocabularyPrompt(input); 

    if (!output || !output.vocabulary) {
      console.error('Vocabulary generation prompt failed or returned empty/invalid data from LLM.');
      // Fallback to empty array or a predefined minimal set if critical
      return []; 
    }

    // Add unique wordBankId to each item
    const vocabularyWithIds = output.vocabulary.map((item, index) => ({
      ...item,
      wordBankId: `${input.languageCode}_${input.modeName.replace(/\s+/g, '-').toLowerCase()}_${Date.now()}_${index}`,
    }));

    return vocabularyWithIds;
  }
);

